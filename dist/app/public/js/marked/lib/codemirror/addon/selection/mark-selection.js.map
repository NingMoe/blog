{"version":3,"sources":["../../../../../../../../../app/public/js/marked/lib/codemirror/addon/selection/mark-selection.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineOption","cm","val","old","prev","Init","state","markedSelection","markedSelectionStyle","reset","on","onCursorActivity","onChange","off","clear","operation","update","length","CHUNK_SIZE","Pos","cmp","cmpPos","coverRange","from","to","addAt","array","cls","line","start","endLine","atEnd","end","mark","markText","className","push","splice","i","ranges","listSelections","somethingSelected","getCursor","coverStart","find","coverEnd","shift","pop"],"mappings":"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","file":"mark-selection.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n"]}