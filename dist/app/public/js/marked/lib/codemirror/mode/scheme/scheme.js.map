{"version":3,"sources":["../../../../../../../../../app/public/js/marked/lib/codemirror/mode/scheme/scheme.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","BUILTIN","COMMENT","STRING","ATOM","NUMBER","BRACKET","INDENT_WORD_SKIP","makeKeywords","str","obj","words","split","i","length","keywords","indentKeys","stateStack","indent","type","prev","pushStack","state","indentStack","popStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","startState","indentation","mode","sExprComment","token","sol","eatSpace","returnType","next","escaped","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","test","skipToEnd","keyWord","indentTemp","column","letter","propertyIsEnumerable","eol","current","lineComment","defineMIME"],"mappings":"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","file":"scheme.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"scheme\", function () {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var keywords = makeKeywords(\"Î» case-lambda call/cc class define-class exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda\");\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\n    function isBinaryNumber (stream) {\n        return stream.match(binaryMatcher);\n    }\n\n    function isOctalNumber (stream) {\n        return stream.match(octalMatcher);\n    }\n\n    function isDecimalNumber (stream, backup) {\n        if (backup === true) {\n            stream.backUp(1);\n        }\n        return stream.match(decimalMatcher);\n    }\n\n    function isHexNumber (stream) {\n        return stream.match(hexMatcher);\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false,\n                sExprComment: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in scheme-string mode\n                    break;\n                case \"comment\": // comment parsing mode\n                    var next, maybeEnd = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"#\" && maybeEnd) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        maybeEnd = (next == \"|\");\n                    }\n                    returnType = COMMENT;\n                    break;\n                case \"s-expr-comment\": // s-expr commenting mode\n                    state.mode = false;\n                    if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n                        // actually start scheme s-expr commenting mode\n                        state.sExprComment = 0;\n                    }else{\n                        // if not we just comment the entire of the next token\n                        stream.eatWhile(/[^/s]/); // eat non spaces\n                        returnType = COMMENT;\n                        break;\n                    }\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n\n                    } else if (ch == \"'\") {\n                        returnType = ATOM;\n                    } else if (ch == '#') {\n                        if (stream.eat(\"|\")) {                    // Multi-line comment\n                            state.mode = \"comment\"; // toggle to comment mode\n                            returnType = COMMENT;\n                        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n                            returnType = ATOM;\n                        } else if (stream.eat(';')) {                // S-Expr comment\n                            state.mode = \"s-expr-comment\";\n                            returnType = COMMENT;\n                        } else {\n                            var numTest = null, hasExactness = false, hasRadix = true;\n                            if (stream.eat(/[ei]/i)) {\n                                hasExactness = true;\n                            } else {\n                                stream.backUp(1);       // must be radix specifier\n                            }\n                            if (stream.match(/^#b/i)) {\n                                numTest = isBinaryNumber;\n                            } else if (stream.match(/^#o/i)) {\n                                numTest = isOctalNumber;\n                            } else if (stream.match(/^#x/i)) {\n                                numTest = isHexNumber;\n                            } else if (stream.match(/^#d/i)) {\n                                numTest = isDecimalNumber;\n                            } else if (stream.match(/^[-+0-9.]/, false)) {\n                                hasRadix = false;\n                                numTest = isDecimalNumber;\n                            // re-consume the intial # if all matches failed\n                            } else if (!hasExactness) {\n                                stream.eat('#');\n                            }\n                            if (numTest != null) {\n                                if (hasRadix && !hasExactness) {\n                                    // consume optional exactness after radix\n                                    stream.match(/^#[ei]/i);\n                                }\n                                if (numTest(stream))\n                                    returnType = NUMBER;\n                            }\n                        }\n                    } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n                        returnType = NUMBER;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (ch == \"(\" || ch == \"[\") {\n                      var keyWord = ''; var indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation 1 space after\n                                pushStack(state, indentTemp + 1, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                            popStack(state);\n\n                            if(typeof state.sExprComment == \"number\"){\n                                if(--state.sExprComment == 0){\n                                    returnType = COMMENT; // final closing bracket\n                                    state.sExprComment = false; // turn off s-expr commenting mode\n                                }\n                            }\n                        }\n                    } else {\n                        stream.eatWhile(/[\\w\\$_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else returnType = \"variable\";\n                    }\n            }\n            return (typeof state.sExprComment == \"number\") ? COMMENT : returnType;\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n\n});\n"]}