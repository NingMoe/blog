{"version":3,"sources":["../../../../../../../../../app/public/js/marked/lib/codemirror/mode/vb/vb.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","conf","parserConf","ERRORCLASS","wordRegexp","words","RegExp","join","singleOperators","singleDelimiters","doubleOperators","doubleDelimiters","tripleDelimiters","identifiers","openingKeywords","middleKeywords","endKeywords","wordOperators","commonkeywords","commontypes","keywords","types","stringPrefixes","opening","middle","closing","doubleClosing","doOpening","indentInfo","indent","_stream","state","currentIndent","dedent","tokenBase","stream","eatSpace","ch","peek","skipToEnd","match","floatLiteral","eat","intLiteral","tokenize","tokenStringFactory","current","doInCurrentLine","next","delimiter","singleline","length","OUTCLASS","eol","eatWhile","singleLineStringErrors","tokenLexer","style","delimiter_index","indexOf","external","electricChars","startState","lastToken","nextLineIndent","token","sol","content","textAfter","trueText","replace","indentUnit","defineMIME"],"mappings":"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","file":"vb.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"vb\", function(conf, parserConf) {\n    var ERRORCLASS = 'error';\n\n    function wordRegexp(words) {\n        return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\", \"i\");\n    }\n\n    var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/%&\\\\\\\\|\\\\^~<>!]\");\n    var singleDelimiters = new RegExp('^[\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}@,:`=;\\\\.]');\n    var doubleOperators = new RegExp(\"^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\\\*\\\\*))\");\n    var doubleDelimiters = new RegExp(\"^((\\\\+=)|(\\\\-=)|(\\\\*=)|(%=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n    var tripleDelimiters = new RegExp(\"^((//=)|(>>=)|(<<=)|(\\\\*\\\\*=))\");\n    var identifiers = new RegExp(\"^[_A-Za-z][_A-Za-z0-9]*\");\n\n    var openingKeywords = ['class','module', 'sub','enum','select','while','if','function',  'get','set','property', 'try'];\n    var middleKeywords = ['else','elseif','case', 'catch'];\n    var endKeywords = ['next','loop'];\n\n    var wordOperators = wordRegexp(['and', 'or', 'not', 'xor', 'in']);\n    var commonkeywords = ['as', 'dim', 'break',  'continue','optional', 'then',  'until',\n                          'goto', 'byval','byref','new','handles','property', 'return',\n                          'const','private', 'protected', 'friend', 'public', 'shared', 'static', 'true','false'];\n    var commontypes = ['integer','string','double','decimal','boolean','short','char', 'float','single'];\n\n    var keywords = wordRegexp(commonkeywords);\n    var types = wordRegexp(commontypes);\n    var stringPrefixes = '\"';\n\n    var opening = wordRegexp(openingKeywords);\n    var middle = wordRegexp(middleKeywords);\n    var closing = wordRegexp(endKeywords);\n    var doubleClosing = wordRegexp(['end']);\n    var doOpening = wordRegexp(['do']);\n\n    var indentInfo = null;\n\n\n\n\n    function indent(_stream, state) {\n      state.currentIndent++;\n    }\n\n    function dedent(_stream, state) {\n      state.currentIndent--;\n    }\n    // tokenizers\n    function tokenBase(stream, state) {\n        if (stream.eatSpace()) {\n            return null;\n        }\n\n        var ch = stream.peek();\n\n        // Handle Comments\n        if (ch === \"'\") {\n            stream.skipToEnd();\n            return 'comment';\n        }\n\n\n        // Handle Number Literals\n        if (stream.match(/^((&H)|(&O))?[0-9\\.a-f]/i, false)) {\n            var floatLiteral = false;\n            // Floats\n            if (stream.match(/^\\d*\\.\\d+F?/i)) { floatLiteral = true; }\n            else if (stream.match(/^\\d+\\.\\d*F?/)) { floatLiteral = true; }\n            else if (stream.match(/^\\.\\d+F?/)) { floatLiteral = true; }\n\n            if (floatLiteral) {\n                // Float literals may be \"imaginary\"\n                stream.eat(/J/i);\n                return 'number';\n            }\n            // Integers\n            var intLiteral = false;\n            // Hex\n            if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }\n            // Octal\n            else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }\n            // Decimal\n            else if (stream.match(/^[1-9]\\d*F?/)) {\n                // Decimal literals may be \"imaginary\"\n                stream.eat(/J/i);\n                // TODO - Can you have imaginary longs?\n                intLiteral = true;\n            }\n            // Zero by itself with no other piece of number.\n            else if (stream.match(/^0(?![\\dx])/i)) { intLiteral = true; }\n            if (intLiteral) {\n                // Integer literals may be \"long\"\n                stream.eat(/L/i);\n                return 'number';\n            }\n        }\n\n        // Handle Strings\n        if (stream.match(stringPrefixes)) {\n            state.tokenize = tokenStringFactory(stream.current());\n            return state.tokenize(stream, state);\n        }\n\n        // Handle operators and Delimiters\n        if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {\n            return null;\n        }\n        if (stream.match(doubleOperators)\n            || stream.match(singleOperators)\n            || stream.match(wordOperators)) {\n            return 'operator';\n        }\n        if (stream.match(singleDelimiters)) {\n            return null;\n        }\n        if (stream.match(doOpening)) {\n            indent(stream,state);\n            state.doInCurrentLine = true;\n            return 'keyword';\n        }\n        if (stream.match(opening)) {\n            if (! state.doInCurrentLine)\n              indent(stream,state);\n            else\n              state.doInCurrentLine = false;\n            return 'keyword';\n        }\n        if (stream.match(middle)) {\n            return 'keyword';\n        }\n\n        if (stream.match(doubleClosing)) {\n            dedent(stream,state);\n            dedent(stream,state);\n            return 'keyword';\n        }\n        if (stream.match(closing)) {\n            dedent(stream,state);\n            return 'keyword';\n        }\n\n        if (stream.match(types)) {\n            return 'keyword';\n        }\n\n        if (stream.match(keywords)) {\n            return 'keyword';\n        }\n\n        if (stream.match(identifiers)) {\n            return 'variable';\n        }\n\n        // Handle non-detected items\n        stream.next();\n        return ERRORCLASS;\n    }\n\n    function tokenStringFactory(delimiter) {\n        var singleline = delimiter.length == 1;\n        var OUTCLASS = 'string';\n\n        return function(stream, state) {\n            while (!stream.eol()) {\n                stream.eatWhile(/[^'\"]/);\n                if (stream.match(delimiter)) {\n                    state.tokenize = tokenBase;\n                    return OUTCLASS;\n                } else {\n                    stream.eat(/['\"]/);\n                }\n            }\n            if (singleline) {\n                if (parserConf.singleLineStringErrors) {\n                    return ERRORCLASS;\n                } else {\n                    state.tokenize = tokenBase;\n                }\n            }\n            return OUTCLASS;\n        };\n    }\n\n\n    function tokenLexer(stream, state) {\n        var style = state.tokenize(stream, state);\n        var current = stream.current();\n\n        // Handle '.' connected identifiers\n        if (current === '.') {\n            style = state.tokenize(stream, state);\n            current = stream.current();\n            if (style === 'variable') {\n                return 'variable';\n            } else {\n                return ERRORCLASS;\n            }\n        }\n\n\n        var delimiter_index = '[({'.indexOf(current);\n        if (delimiter_index !== -1) {\n            indent(stream, state );\n        }\n        if (indentInfo === 'dedent') {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n        delimiter_index = '])}'.indexOf(current);\n        if (delimiter_index !== -1) {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n\n        return style;\n    }\n\n    var external = {\n        electricChars:\"dDpPtTfFeE \",\n        startState: function() {\n            return {\n              tokenize: tokenBase,\n              lastToken: null,\n              currentIndent: 0,\n              nextLineIndent: 0,\n              doInCurrentLine: false\n\n\n          };\n        },\n\n        token: function(stream, state) {\n            if (stream.sol()) {\n              state.currentIndent += state.nextLineIndent;\n              state.nextLineIndent = 0;\n              state.doInCurrentLine = 0;\n            }\n            var style = tokenLexer(stream, state);\n\n            state.lastToken = {style:style, content: stream.current()};\n\n\n\n            return style;\n        },\n\n        indent: function(state, textAfter) {\n            var trueText = textAfter.replace(/^\\s+|\\s+$/g, '') ;\n            if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);\n            if(state.currentIndent < 0) return 0;\n            return state.currentIndent * conf.indentUnit;\n        }\n\n    };\n    return external;\n});\n\nCodeMirror.defineMIME(\"text/x-vb\", \"vb\");\n\n});\n"]}