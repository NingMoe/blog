{"version":3,"sources":["../../../../../../../../../app/public/js/marked/lib/codemirror/mode/clojure/clojure.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","options","BUILTIN","COMMENT","STRING","CHARACTER","ATOM","NUMBER","BRACKET","KEYWORD","VAR","INDENT_WORD_SKIP","indentUnit","NORMAL_INDENT_UNIT","makeKeywords","str","obj","words","split","i","length","atoms","keywords","builtins","indentKeys","tests","digit","digit_or_colon","hex","sign","exponent","keyword_char","symbol","stateStack","indent","type","prev","pushStack","state","indentStack","popStack","isNumber","ch","stream","eat","eatWhile","test","peek","next","eatCharacter","first","match","startState","indentation","mode","token","sol","eatSpace","returnType","escaped","skipToEnd","keyWord","indentTemp","column","letter","propertyIsEnumerable","eol","current","backUp","lineComment","defineMIME"],"mappings":";;;;AAAA;AACA;;AAEA;;;;;AAKA,CAAC,UAASA,GAAT,EAAc;AACb,QAAI,QAAOC,OAAP,yCAAOA,OAAP,MAAkB,QAAlB,IAA8B,QAAOC,MAAP,yCAAOA,MAAP,MAAiB,QAAnD,EAA6D;AAC3DF,YAAIG,QAAQ,sBAAR,CAAJ,EADF,KAEK,IAAI,OAAOC,MAAP,IAAiB,UAAjB,IAA+BA,OAAOC,GAA1C,EAA+C;AAClDD,eAAO,CAAC,sBAAD,CAAP,EAAiCJ,GAAjC,EADG,KAEA;AACHA,YAAIM,UAAJ;AACH,CAPD,EAOG,UAASA,UAAT,EAAqB;AACxB;;AAEAA,eAAWC,UAAX,CAAsB,SAAtB,EAAiC,UAAUC,OAAV,EAAmB;AAChD,YAAIC,UAAU,SAAd;AAAA,YAAyBC,UAAU,SAAnC;AAAA,YAA8CC,SAAS,QAAvD;AAAA,YAAiEC,YAAY,UAA7E;AAAA,YACIC,OAAO,MADX;AAAA,YACmBC,SAAS,QAD5B;AAAA,YACsCC,UAAU,SADhD;AAAA,YAC2DC,UAAU,SADrE;AAAA,YACgFC,MAAM,UADtF;AAEA,YAAIC,mBAAmBV,QAAQW,UAAR,IAAsB,CAA7C;AACA,YAAIC,qBAAqBZ,QAAQW,UAAR,IAAsB,CAA/C;;AAEA,iBAASE,YAAT,CAAsBC,GAAtB,EAA2B;AACvB,gBAAIC,MAAM,EAAV;AAAA,gBAAcC,QAAQF,IAAIG,KAAJ,CAAU,GAAV,CAAtB;AACA,iBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,MAAMG,MAA1B,EAAkC,EAAED,CAApC;AAAuCH,oBAAIC,MAAME,CAAN,CAAJ,IAAgB,IAAhB;AAAvC,aACA,OAAOH,GAAP;AACH;;AAED,YAAIK,QAAQP,aAAa,gBAAb,CAAZ;;AAEA,YAAIQ,WAAWR,aACb,shBADa,CAAf;;AAGA,YAAIS,WAAWT,aACX,27KADW,CAAf;;AAGA,YAAIU,aAAaV;AACb;AACA;;AAEA;AACA,mEAHA;;AAKA;AACA,qCANA;;AAQA;AACA,0BATA;;AAWA;AACA,8CAda,CAAjB;;AAgBA,YAAIW,QAAQ;AACRC,mBAAO,IADC;AAERC,4BAAgB,OAFR;AAGRC,iBAAK,WAHG;AAIRC,kBAAM,MAJE;AAKRC,sBAAU,IALF;AAMRC,0BAAc,iBANN;AAORC,oBAAQ;AAPA,SAAZ;;AAUA,iBAASC,UAAT,CAAoBC,MAApB,EAA4BC,IAA5B,EAAkCC,IAAlC,EAAwC;AAAE;AACtC,iBAAKF,MAAL,GAAcA,MAAd;AACA,iBAAKC,IAAL,GAAYA,IAAZ;AACA,iBAAKC,IAAL,GAAYA,IAAZ;AACH;;AAED,iBAASC,SAAT,CAAmBC,KAAnB,EAA0BJ,MAA1B,EAAkCC,IAAlC,EAAwC;AACpCG,kBAAMC,WAAN,GAAoB,IAAIN,UAAJ,CAAeC,MAAf,EAAuBC,IAAvB,EAA6BG,MAAMC,WAAnC,CAApB;AACH;;AAED,iBAASC,QAAT,CAAkBF,KAAlB,EAAyB;AACrBA,kBAAMC,WAAN,GAAoBD,MAAMC,WAAN,CAAkBH,IAAtC;AACH;;AAED,iBAASK,QAAT,CAAkBC,EAAlB,EAAsBC,MAAtB,EAA6B;AACzB;AACA,gBAAKD,OAAO,GAAP,IAAcC,OAAOC,GAAP,CAAW,IAAX,CAAnB,EAAsC;AAClCD,uBAAOE,QAAP,CAAgBpB,MAAMG,GAAtB;AACA,uBAAO,IAAP;AACH;;AAED;AACA,gBAAK,CAAEc,MAAM,GAAN,IAAaA,MAAM,GAArB,KAAgCjB,MAAMC,KAAN,CAAYoB,IAAZ,CAAiBH,OAAOI,IAAP,EAAjB,CAArC,EAAyE;AACvEJ,uBAAOC,GAAP,CAAWnB,MAAMI,IAAjB;AACAa,qBAAKC,OAAOK,IAAP,EAAL;AACD;;AAED,gBAAKvB,MAAMC,KAAN,CAAYoB,IAAZ,CAAiBJ,EAAjB,CAAL,EAA4B;AACxBC,uBAAOC,GAAP,CAAWF,EAAX;AACAC,uBAAOE,QAAP,CAAgBpB,MAAMC,KAAtB;;AAEA,oBAAK,OAAOiB,OAAOI,IAAP,EAAZ,EAA4B;AACxBJ,2BAAOC,GAAP,CAAW,GAAX;AACAD,2BAAOE,QAAP,CAAgBpB,MAAMC,KAAtB;AACH;;AAED,oBAAKiB,OAAOC,GAAP,CAAWnB,MAAMK,QAAjB,CAAL,EAAkC;AAC9Ba,2BAAOC,GAAP,CAAWnB,MAAMI,IAAjB;AACAc,2BAAOE,QAAP,CAAgBpB,MAAMC,KAAtB;AACH;;AAED,uBAAO,IAAP;AACH;;AAED,mBAAO,KAAP;AACH;;AAED;AACA,iBAASuB,YAAT,CAAsBN,MAAtB,EAA8B;AAC1B,gBAAIO,QAAQP,OAAOK,IAAP,EAAZ;AACA;AACA;AACA,gBAAIE,SAASA,MAAMC,KAAN,CAAY,OAAZ,CAAT,IAAiCR,OAAOQ,KAAP,CAAa,QAAb,EAAuB,IAAvB,CAArC,EAAmE;AAC/D;AACH;AACD;AACA,gBAAID,UAAU,GAAd,EAAmB;AACfP,uBAAOQ,KAAP,CAAa,cAAb,EAA6B,IAA7B;AACH;AACJ;;AAED,eAAO;AACHC,wBAAY,sBAAY;AACpB,uBAAO;AACHb,iCAAa,IADV;AAEHc,iCAAa,CAFV;AAGHC,0BAAM;AAHH,iBAAP;AAKH,aAPE;;AASHC,mBAAO,eAAUZ,MAAV,EAAkBL,KAAlB,EAAyB;AAC5B,oBAAIA,MAAMC,WAAN,IAAqB,IAArB,IAA6BI,OAAOa,GAAP,EAAjC,EAA+C;AAC3C;AACAlB,0BAAMe,WAAN,GAAoBV,OAAOU,WAAP,EAApB;AACH;;AAED;AACA,oBAAIV,OAAOc,QAAP,EAAJ,EAAuB;AACnB,2BAAO,IAAP;AACH;AACD,oBAAIC,aAAa,IAAjB;;AAEA,wBAAOpB,MAAMgB,IAAb;AACI,yBAAK,QAAL;AAAe;AACX,4BAAIN,IAAJ;AAAA,4BAAUW,UAAU,KAApB;AACA,+BAAO,CAACX,OAAOL,OAAOK,IAAP,EAAR,KAA0B,IAAjC,EAAuC;AACnC,gCAAIA,QAAQ,IAAR,IAAgB,CAACW,OAArB,EAA8B;;AAE1BrB,sCAAMgB,IAAN,GAAa,KAAb;AACA;AACH;AACDK,sCAAU,CAACA,OAAD,IAAYX,QAAQ,IAA9B;AACH;AACDU,qCAAatD,MAAb,CAVJ,CAUyB;AACrB;AACJ;AAAS;AACL,4BAAIsC,KAAKC,OAAOK,IAAP,EAAT;;AAEA,4BAAIN,MAAM,IAAV,EAAgB;AACZJ,kCAAMgB,IAAN,GAAa,QAAb;AACAI,yCAAatD,MAAb;AACH,yBAHD,MAGO,IAAIsC,MAAM,IAAV,EAAgB;AACnBO,yCAAaN,MAAb;AACAe,yCAAarD,SAAb;AACH,yBAHM,MAGA,IAAIqC,MAAM,GAAN,IAAa,CAAGjB,MAAME,cAAN,CAAqBmB,IAArB,CAA0BH,OAAOI,IAAP,EAA1B,CAApB,EAAgE;AACnEW,yCAAapD,IAAb;AACH,yBAFM,MAEA,IAAIoC,MAAM,GAAV,EAAe;AAAE;AACpBC,mCAAOiB,SAAP,GADkB,CACE;AACpBF,yCAAavD,OAAb;AACH,yBAHM,MAGA,IAAIsC,SAASC,EAAT,EAAYC,MAAZ,CAAJ,EAAwB;AAC3Be,yCAAanD,MAAb;AACH,yBAFM,MAEA,IAAImC,MAAM,GAAN,IAAaA,MAAM,GAAnB,IAA0BA,MAAM,GAApC,EAA0C;AAC7C,gCAAImB,UAAU,EAAd;AAAA,gCAAkBC,aAAanB,OAAOoB,MAAP,EAA/B;AAAA,gCAAgDC,MAAhD;AACA;;;;;;;AAOA,gCAAItB,MAAM,GAAV,EAAe,OAAO,CAACsB,SAASrB,OAAOC,GAAP,CAAWnB,MAAMM,YAAjB,CAAV,KAA6C,IAApD,EAA0D;AACrE8B,2CAAWG,MAAX;AACH;;AAED,gCAAIH,QAAQzC,MAAR,GAAiB,CAAjB,KAAuBI,WAAWyC,oBAAX,CAAgCJ,OAAhC,KACA,gBAAgBf,IAAhB,CAAqBe,OAArB,CADvB,CAAJ,EAC2D;AAAE;AACzDxB,0CAAUC,KAAV,EAAiBwB,aAAanD,gBAA9B,EAAgD+B,EAAhD;AACH,6BAHD,MAGO;AAAE;AACL;AACAC,uCAAOc,QAAP;AACA,oCAAId,OAAOuB,GAAP,MAAgBvB,OAAOI,IAAP,MAAiB,GAArC,EAA0C;AACtC;AACA;AACAV,8CAAUC,KAAV,EAAiBwB,aAAajD,kBAA9B,EAAkD6B,EAAlD;AACH,iCAJD,MAIO;AACHL,8CAAUC,KAAV,EAAiBwB,aAAanB,OAAOwB,OAAP,GAAiB/C,MAA/C,EAAuDsB,EAAvD,EADG,CACyD;AAC/D;AACJ;AACDC,mCAAOyB,MAAP,CAAczB,OAAOwB,OAAP,GAAiB/C,MAAjB,GAA0B,CAAxC,EA3B6C,CA2BD;;AAE5CsC,yCAAalD,OAAb;AACH,yBA9BM,MA8BA,IAAIkC,MAAM,GAAN,IAAaA,MAAM,GAAnB,IAA0BA,MAAM,GAApC,EAAyC;AAC5CgB,yCAAalD,OAAb;AACA,gCAAI8B,MAAMC,WAAN,IAAqB,IAArB,IAA6BD,MAAMC,WAAN,CAAkBJ,IAAlB,KAA2BO,MAAM,GAAN,GAAY,GAAZ,GAAmBA,MAAM,GAAN,GAAY,GAAZ,GAAiB,GAA/D,CAAjC,EAAuG;AACnGF,yCAASF,KAAT;AACH;AACJ,yBALM,MAKA,IAAKI,MAAM,GAAX,EAAiB;AACpBC,mCAAOE,QAAP,CAAgBpB,MAAMO,MAAtB;AACA,mCAAO1B,IAAP;AACH,yBAHM,MAGA;AACHqC,mCAAOE,QAAP,CAAgBpB,MAAMO,MAAtB;;AAEA,gCAAIV,YAAYA,SAAS2C,oBAAT,CAA8BtB,OAAOwB,OAAP,EAA9B,CAAhB,EAAiE;AAC7DT,6CAAajD,OAAb;AACH,6BAFD,MAEO,IAAIc,YAAYA,SAAS0C,oBAAT,CAA8BtB,OAAOwB,OAAP,EAA9B,CAAhB,EAAiE;AACpET,6CAAaxD,OAAb;AACH,6BAFM,MAEA,IAAImB,SAASA,MAAM4C,oBAAN,CAA2BtB,OAAOwB,OAAP,EAA3B,CAAb,EAA2D;AAC9DT,6CAAapD,IAAb;AACH,6BAFM,MAEA;AACLoD,6CAAahD,GAAb;AACD;AACJ;AA/ET;;AAkFA,uBAAOgD,UAAP;AACH,aAxGE;;AA0GHxB,oBAAQ,gBAAUI,KAAV,EAAiB;AACrB,oBAAIA,MAAMC,WAAN,IAAqB,IAAzB,EAA+B,OAAOD,MAAMe,WAAb;AAC/B,uBAAOf,MAAMC,WAAN,CAAkBL,MAAzB;AACH,aA7GE;;AA+GHmC,yBAAa;AA/GV,SAAP;AAiHH,KA5ND;;AA8NAtE,eAAWuE,UAAX,CAAsB,gBAAtB,EAAwC,SAAxC;AAEC,CA1OD","file":"clojure.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Author: Hans Engel\n * Branched from CodeMirror's Scheme mode (by Koh Zi Han, based on implementation by Koh Zi Chun)\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"clojure\", function (options) {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\", CHARACTER = \"string-2\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\", KEYWORD = \"keyword\", VAR = \"variable\";\n    var INDENT_WORD_SKIP = options.indentUnit || 2;\n    var NORMAL_INDENT_UNIT = options.indentUnit || 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var atoms = makeKeywords(\"true false nil\");\n\n    var keywords = makeKeywords(\n      \"defn defn- def def- defonce defmulti defmethod defmacro defstruct deftype defprotocol defrecord defproject deftest slice defalias defhinted defmacro- defn-memo defnk defnk defonce- defunbound defunbound- defvar defvar- let letfn do case cond condp for loop recur when when-not when-let when-first if if-let if-not . .. -> ->> doto and or dosync doseq dotimes dorun doall load import unimport ns in-ns refer try catch finally throw with-open with-local-vars binding gen-class gen-and-load-class gen-and-save-class handler-case handle\");\n\n    var builtins = makeKeywords(\n        \"* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* *compile-path* *compiler-options* *data-readers* *e *err* *file* *flush-on-newline* *fn-loader* *in* *math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* *source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -> ->> ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods .. / < <= = == > >= EMPTY-NODE accessor aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* bound? butlast byte byte-array bytes case cast char char-array char-escape-string char-name-string char? chars chunk chunk-append chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement concat cond condp conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? declare default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array doubles drop drop-last drop-while empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash hash-combine hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc inc' init-proxy instance? int int-array integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array make-hierarchy map map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods min min-key mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty not-every? not= ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot rand rand-int rand-nth range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern re-seq read read-line read-string realized? reduce reduce-kv reductions ref ref-history-count ref-max-history ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off seq seq? seque sequence sequential? set set-error-handler! set-error-mode! set-validator! set? short short-array shorts shuffle shutdown-agents slurp some some-fn sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol symbol? sync take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote unquote-splicing update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of vector? when when-first when-let when-not while with-bindings with-bindings* with-in-str with-loading-context with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap *default-data-reader-fn* as-> cond-> cond->> reduced reduced? send-via set-agent-send-executor! set-agent-send-off-executor! some-> some->>\");\n\n    var indentKeys = makeKeywords(\n        // Built-ins\n        \"ns fn def defn defmethod bound-fn if if-not case condp when while when-not when-first do future comment doto locking proxy with-open with-precision reify deftype defrecord defprotocol extend extend-protocol extend-type try catch \" +\n\n        // Binding forms\n        \"let letfn binding loop for doseq dotimes when-let if-let \" +\n\n        // Data structures\n        \"defstruct struct-map assoc \" +\n\n        // clojure.test\n        \"testing deftest \" +\n\n        // contrib\n        \"handler-case handle dotrace deftrace\");\n\n    var tests = {\n        digit: /\\d/,\n        digit_or_colon: /[\\d:]/,\n        hex: /[0-9a-f]/i,\n        sign: /[+-]/,\n        exponent: /e/i,\n        keyword_char: /[^\\s\\(\\[\\;\\)\\]]/,\n        symbol: /[\\w*+!\\-\\._?:<>\\/\\xa1-\\uffff]/\n    };\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    function isNumber(ch, stream){\n        // hex\n        if ( ch === '0' && stream.eat(/x/i) ) {\n            stream.eatWhile(tests.hex);\n            return true;\n        }\n\n        // leading sign\n        if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {\n          stream.eat(tests.sign);\n          ch = stream.next();\n        }\n\n        if ( tests.digit.test(ch) ) {\n            stream.eat(ch);\n            stream.eatWhile(tests.digit);\n\n            if ( '.' == stream.peek() ) {\n                stream.eat('.');\n                stream.eatWhile(tests.digit);\n            }\n\n            if ( stream.eat(tests.exponent) ) {\n                stream.eat(tests.sign);\n                stream.eatWhile(tests.digit);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // Eat character that starts after backslash \\\n    function eatCharacter(stream) {\n        var first = stream.next();\n        // Read special literals: backspace, newline, space, return.\n        // Just read all lowercase letters.\n        if (first && first.match(/[a-z]/) && stream.match(/[a-z]+/, true)) {\n            return;\n        }\n        // Read unicode character: \\u1000 \\uA0a1\n        if (first === \"u\") {\n            stream.match(/[0-9a-z]{4}/i, true);\n        }\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in string mode\n                    break;\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n                    } else if (ch == \"\\\\\") {\n                        eatCharacter(stream);\n                        returnType = CHARACTER;\n                    } else if (ch == \"'\" && !( tests.digit_or_colon.test(stream.peek()) )) {\n                        returnType = ATOM;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (isNumber(ch,stream)){\n                        returnType = NUMBER;\n                    } else if (ch == \"(\" || ch == \"[\" || ch == \"{\" ) {\n                        var keyWord = '', indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        if (ch == \"(\") while ((letter = stream.eat(tests.keyword_char)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && (indentKeys.propertyIsEnumerable(keyWord) ||\n                                                   /^(?:def|with)/.test(keyWord))) { // indent-word\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation the user defined spaces after\n                                pushStack(state, indentTemp + NORMAL_INDENT_UNIT, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\" || ch == \"}\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : (ch == \"]\" ? \"[\" :\"{\"))) {\n                            popStack(state);\n                        }\n                    } else if ( ch == \":\" ) {\n                        stream.eatWhile(tests.symbol);\n                        return ATOM;\n                    } else {\n                        stream.eatWhile(tests.symbol);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = KEYWORD;\n                        } else if (builtins && builtins.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else if (atoms && atoms.propertyIsEnumerable(stream.current())) {\n                            returnType = ATOM;\n                        } else {\n                          returnType = VAR;\n                        }\n                    }\n            }\n\n            return returnType;\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-clojure\", \"clojure\");\n\n});\n"]}