{"version":3,"sources":["../../../../../../../../../app/public/js/marked/lib/codemirror/mode/xquery/xquery.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","keywords","kw","type","style","A","B","C","operator","atom","punctuation","qualifier","kwObj","basic","i","l","length","types","operators","axis_specifiers","content","ret","tp","cont","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","isEQNameAhead","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","tagName","c","tokenTag","pushStateStack","popStateStack","isInXmlBlock","test","tokenComment","tokenString","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","current","isInXmlConstructor","maybeEnd","maybeNested","nestedCount","quote","isInString","name","isInXmlAttributeBlock","isVariableChar","tokenAttribute","isIn","stack","newState","push","pop","reinstateTokenize","startState","cc","token","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"xquery.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xquery\", function() {\n\n  // The keywords object is set to the result of this self executing\n  // function. Each keyword is a property of the keywords object whose\n  // value is {type: atype, style: astyle}\n  var keywords = function(){\n    // conveinence functions used to build keywords object\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\")\n      , B = kw(\"keyword b\")\n      , C = kw(\"keyword c\")\n      , operator = kw(\"operator\")\n      , atom = {type: \"atom\", style: \"atom\"}\n      , punctuation = {type: \"punctuation\", style: null}\n      , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n    // kwObj is what is return from this function at the end\n    var kwObj = {\n      'if': A, 'switch': A, 'while': A, 'for': A,\n      'else': B, 'then': B, 'try': B, 'finally': B, 'catch': B,\n      'element': C, 'attribute': C, 'let': C, 'implements': C, 'import': C, 'module': C, 'namespace': C,\n      'return': C, 'super': C, 'this': C, 'throws': C, 'where': C, 'private': C,\n      ',': punctuation,\n      'null': atom, 'fn:false()': atom, 'fn:true()': atom\n    };\n\n    // a list of 'basic' keywords. For each add a property to kwObj with the value of\n    // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n    var basic = ['after','ancestor','ancestor-or-self','and','as','ascending','assert','attribute','before',\n    'by','case','cast','child','comment','declare','default','define','descendant','descendant-or-self',\n    'descending','document','document-node','element','else','eq','every','except','external','following',\n    'following-sibling','follows','for','function','if','import','in','instance','intersect','item',\n    'let','module','namespace','node','node','of','only','or','order','parent','precedes','preceding',\n    'preceding-sibling','processing-instruction','ref','return','returns','satisfies','schema','schema-element',\n    'self','some','sortby','stable','text','then','to','treat','typeswitch','union','variable','version','where',\n    'xquery', 'empty-sequence'];\n    for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n    // a list of types. For each add a property to kwObj with the value of\n    // {type: \"atom\", style: \"atom\"}\n    var types = ['xs:string', 'xs:float', 'xs:decimal', 'xs:double', 'xs:integer', 'xs:boolean', 'xs:date', 'xs:dateTime',\n    'xs:time', 'xs:duration', 'xs:dayTimeDuration', 'xs:time', 'xs:yearMonthDuration', 'numeric', 'xs:hexBinary',\n    'xs:base64Binary', 'xs:anyURI', 'xs:QName', 'xs:byte','xs:boolean','xs:anyURI','xf:yearMonthDuration'];\n    for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n    // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n    var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n    for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n    // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n    var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n    \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n    for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n    return kwObj;\n  }();\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  // the primary mode tokenizer\n  function tokenBase(stream, state) {\n    var ch = stream.next(),\n        mightBeFunction = false,\n        isEQName = isEQNameAhead(stream);\n\n    // an XML tag (if not in some sub, chained tokenizer)\n    if (ch == \"<\") {\n      if(stream.match(\"!--\", true))\n        return chain(stream, state, tokenXMLComment);\n\n      if(stream.match(\"![CDATA\", false)) {\n        state.tokenize = tokenCDATA;\n        return ret(\"tag\", \"tag\");\n      }\n\n      if(stream.match(\"?\", false)) {\n        return chain(stream, state, tokenPreProcessing);\n      }\n\n      var isclose = stream.eat(\"/\");\n      stream.eatSpace();\n      var tagName = \"\", c;\n      while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n      return chain(stream, state, tokenTag(tagName, isclose));\n    }\n    // start code block\n    else if(ch == \"{\") {\n      pushStateStack(state,{ type: \"codeblock\"});\n      return ret(\"\", null);\n    }\n    // end code block\n    else if(ch == \"}\") {\n      popStateStack(state);\n      return ret(\"\", null);\n    }\n    // if we're in an XML block\n    else if(isInXmlBlock(state)) {\n      if(ch == \">\")\n        return ret(\"tag\", \"tag\");\n      else if(ch == \"/\" && stream.eat(\">\")) {\n        popStateStack(state);\n        return ret(\"tag\", \"tag\");\n      }\n      else\n        return ret(\"word\", \"variable\");\n    }\n    // if a number\n    else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n      return ret(\"number\", \"atom\");\n    }\n    // comment start\n    else if (ch === \"(\" && stream.eat(\":\")) {\n      pushStateStack(state, { type: \"comment\"});\n      return chain(stream, state, tokenComment);\n    }\n    // quoted string\n    else if (  !isEQName && (ch === '\"' || ch === \"'\"))\n      return chain(stream, state, tokenString(ch));\n    // variable\n    else if(ch === \"$\") {\n      return chain(stream, state, tokenVariable);\n    }\n    // assignment\n    else if(ch ===\":\" && stream.eat(\"=\")) {\n      return ret(\"operator\", \"keyword\");\n    }\n    // open paren\n    else if(ch === \"(\") {\n      pushStateStack(state, { type: \"paren\"});\n      return ret(\"\", null);\n    }\n    // close paren\n    else if(ch === \")\") {\n      popStateStack(state);\n      return ret(\"\", null);\n    }\n    // open paren\n    else if(ch === \"[\") {\n      pushStateStack(state, { type: \"bracket\"});\n      return ret(\"\", null);\n    }\n    // close paren\n    else if(ch === \"]\") {\n      popStateStack(state);\n      return ret(\"\", null);\n    }\n    else {\n      var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n      // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n      if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n      if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n      // gobble up a word if the character is not known\n      if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n      // gobble a colon in the case that is a lib func type call fn:doc\n      var foundColon = stream.eat(\":\");\n\n      // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n      // which should get matched as a keyword\n      if(!stream.eat(\":\") && foundColon) {\n        stream.eatWhile(/[\\w\\$_-]/);\n      }\n      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n      if(stream.match(/^[ \\t]*\\(/, false)) {\n        mightBeFunction = true;\n      }\n      // is the word a keyword?\n      var word = stream.current();\n      known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n      // if we think it's a function call but not yet known,\n      // set style to variable for now for lack of something better\n      if(mightBeFunction && !known) known = {type: \"function_call\", style: \"variable def\"};\n\n      // if the previous word was element, attribute, axis specifier, this word should be the name of that\n      if(isInXmlConstructor(state)) {\n        popStateStack(state);\n        return ret(\"word\", \"variable\", word);\n      }\n      // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n      // push the stack so we know to look for it on the next word\n      if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n      // if the word is known, return the details of that else just call this a generic 'word'\n      return known ? ret(known.type, known.style, word) :\n                     ret(\"word\", \"variable\", word);\n    }\n  }\n\n  // handle comments, including nested\n  function tokenComment(stream, state) {\n    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n    while (ch = stream.next()) {\n      if (ch == \")\" && maybeEnd) {\n        if(nestedCount > 0)\n          nestedCount--;\n        else {\n          popStateStack(state);\n          break;\n        }\n      }\n      else if(ch == \":\" && maybeNested) {\n        nestedCount++;\n      }\n      maybeEnd = (ch == \":\");\n      maybeNested = (ch == \"(\");\n    }\n\n    return ret(\"comment\", \"comment\");\n  }\n\n  // tokenizer for string literals\n  // optionally pass a tokenizer function to set state.tokenize back to when finished\n  function tokenString(quote, f) {\n    return function(stream, state) {\n      var ch;\n\n      if(isInString(state) && stream.current() == quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        return ret(\"string\", \"string\");\n      }\n\n      pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n      // if we're in a string and in an XML block, allow an embedded code block\n      if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        state.tokenize = tokenBase;\n        return ret(\"string\", \"string\");\n      }\n\n\n      while (ch = stream.next()) {\n        if (ch ==  quote) {\n          popStateStack(state);\n          if(f) state.tokenize = f;\n          break;\n        }\n        else {\n          // if we're in a string and in an XML block, allow an embedded code block in an attribute\n          if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n            state.tokenize = tokenBase;\n            return ret(\"string\", \"string\");\n          }\n\n        }\n      }\n\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  // tokenizer for variables\n  function tokenVariable(stream, state) {\n    var isVariableChar = /[\\w\\$_-]/;\n\n    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n    if(stream.eat(\"\\\"\")) {\n      while(stream.next() !== '\\\"'){};\n      stream.eat(\":\");\n    } else {\n      stream.eatWhile(isVariableChar);\n      if(!stream.match(\":=\", false)) stream.eat(\":\");\n    }\n    stream.eatWhile(isVariableChar);\n    state.tokenize = tokenBase;\n    return ret(\"variable\", \"variable\");\n  }\n\n  // tokenizer for XML tags\n  function tokenTag(name, isclose) {\n    return function(stream, state) {\n      stream.eatSpace();\n      if(isclose && stream.eat(\">\")) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n        return ret(\"tag\", \"tag\");\n      }\n      // self closing tag without attributes?\n      if(!stream.eat(\"/\"))\n        pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n      if(!stream.eat(\">\")) {\n        state.tokenize = tokenAttribute;\n        return ret(\"tag\", \"tag\");\n      }\n      else {\n        state.tokenize = tokenBase;\n      }\n      return ret(\"tag\", \"tag\");\n    };\n  }\n\n  // tokenizer for XML attributes\n  function tokenAttribute(stream, state) {\n    var ch = stream.next();\n\n    if(ch == \"/\" && stream.eat(\">\")) {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      if(isInXmlBlock(state)) popStateStack(state);\n      return ret(\"tag\", \"tag\");\n    }\n    if(ch == \">\") {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      return ret(\"tag\", \"tag\");\n    }\n    if(ch == \"=\")\n      return ret(\"\", null);\n    // quoted string\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, tokenString(ch, tokenAttribute));\n\n    if(!isInXmlAttributeBlock(state))\n      pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n    stream.eat(/[a-zA-Z_:]/);\n    stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n    stream.eatSpace();\n\n    // the case where the attribute has not value and the tag was closed\n    if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n    }\n\n    return ret(\"attribute\", \"attribute\");\n  }\n\n  // handle comments, including nested\n  function tokenXMLComment(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"-\" && stream.match(\"->\", true)) {\n        state.tokenize = tokenBase;\n        return ret(\"comment\", \"comment\");\n      }\n    }\n  }\n\n\n  // handle CDATA\n  function tokenCDATA(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"]\" && stream.match(\"]\", true)) {\n        state.tokenize = tokenBase;\n        return ret(\"comment\", \"comment\");\n      }\n    }\n  }\n\n  // handle preprocessing instructions\n  function tokenPreProcessing(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"?\" && stream.match(\">\", true)) {\n        state.tokenize = tokenBase;\n        return ret(\"comment\", \"comment meta\");\n      }\n    }\n  }\n\n\n  // functions to test the current context of the state\n  function isInXmlBlock(state) { return isIn(state, \"tag\"); }\n  function isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\n  function isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\n  function isInString(state) { return isIn(state, \"string\"); }\n\n  function isEQNameAhead(stream) {\n    // assume we've already eaten a quote (\")\n    if(stream.current() === '\"')\n      return stream.match(/^[^\\\"]+\\\"\\:/, false);\n    else if(stream.current() === '\\'')\n      return stream.match(/^[^\\\"]+\\'\\:/, false);\n    else\n      return false;\n  }\n\n  function isIn(state, type) {\n    return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n  }\n\n  function pushStateStack(state, newState) {\n    state.stack.push(newState);\n  }\n\n  function popStateStack(state) {\n    state.stack.pop();\n    var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n    state.tokenize = reinstateTokenize || tokenBase;\n  }\n\n  // the interface for the mode API\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        cc: [],\n        stack: []\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      return style;\n    },\n\n    blockCommentStart: \"(:\",\n    blockCommentEnd: \":)\"\n\n  };\n\n});\n\nCodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n\n});\n"]}