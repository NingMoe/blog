{"version":3,"sources":["../../../../../../../../../app/public/js/marked/lib/codemirror/mode/velocity/velocity.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","parseWords","str","obj","words","split","i","length","keywords","functions","specials","isOperatorChar","chain","stream","state","f","tokenize","tokenBase","beforeParams","ch","next","inParams","lastTokenWasBuiltin","tokenString","inString","test","eatWhile","eat","tokenComment","match","tokenUnparsed","skipToEnd","propertyIsEnumerable","current","word","peek","toLowerCase","pos","string","charAt","quote","escaped","end","maybeEnd","startState","token","eatSpace","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME"],"mappings":"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","file":"velocity.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"velocity\", function() {\n    function parseWords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var keywords = parseWords(\"#end #else #break #stop #[[ #]] \" +\n                              \"#{end} #{else} #{break} #{stop}\");\n    var functions = parseWords(\"#if #elseif #foreach #set #include #parse #macro #define #evaluate \" +\n                               \"#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}\");\n    var specials = parseWords(\"$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent.count $foreach.parent.hasNext $foreach.parent.first $foreach.parent.last $foreach.parent $velocityCount $!bodyContent $bodyContent\");\n    var isOperatorChar = /[+\\-*&%=<>!?:\\/|]/;\n\n    function chain(stream, state, f) {\n        state.tokenize = f;\n        return f(stream, state);\n    }\n    function tokenBase(stream, state) {\n        var beforeParams = state.beforeParams;\n        state.beforeParams = false;\n        var ch = stream.next();\n        // start of unparsed string?\n        if ((ch == \"'\") && state.inParams) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenString(ch));\n        }\n        // start of parsed string?\n        else if ((ch == '\"')) {\n            state.lastTokenWasBuiltin = false;\n            if (state.inString) {\n                state.inString = false;\n                return \"string\";\n            }\n            else if (state.inParams)\n                return chain(stream, state, tokenString(ch));\n        }\n        // is it one of the special signs []{}().,;? Seperator?\n        else if (/[\\[\\]{}\\(\\),;\\.]/.test(ch)) {\n            if (ch == \"(\" && beforeParams)\n                state.inParams = true;\n            else if (ch == \")\") {\n                state.inParams = false;\n                state.lastTokenWasBuiltin = true;\n            }\n            return null;\n        }\n        // start of a number value?\n        else if (/\\d/.test(ch)) {\n            state.lastTokenWasBuiltin = false;\n            stream.eatWhile(/[\\w\\.]/);\n            return \"number\";\n        }\n        // multi line comment?\n        else if (ch == \"#\" && stream.eat(\"*\")) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenComment);\n        }\n        // unparsed content?\n        else if (ch == \"#\" && stream.match(/ *\\[ *\\[/)) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenUnparsed);\n        }\n        // single line comment?\n        else if (ch == \"#\" && stream.eat(\"#\")) {\n            state.lastTokenWasBuiltin = false;\n            stream.skipToEnd();\n            return \"comment\";\n        }\n        // variable?\n        else if (ch == \"$\") {\n            stream.eatWhile(/[\\w\\d\\$_\\.{}]/);\n            // is it one of the specials?\n            if (specials && specials.propertyIsEnumerable(stream.current())) {\n                return \"keyword\";\n            }\n            else {\n                state.lastTokenWasBuiltin = true;\n                state.beforeParams = true;\n                return \"builtin\";\n            }\n        }\n        // is it a operator?\n        else if (isOperatorChar.test(ch)) {\n            state.lastTokenWasBuiltin = false;\n            stream.eatWhile(isOperatorChar);\n            return \"operator\";\n        }\n        else {\n            // get the whole word\n            stream.eatWhile(/[\\w\\$_{}@]/);\n            var word = stream.current();\n            // is it one of the listed keywords?\n            if (keywords && keywords.propertyIsEnumerable(word))\n                return \"keyword\";\n            // is it one of the listed functions?\n            if (functions && functions.propertyIsEnumerable(word) ||\n                    (stream.current().match(/^#@?[a-z0-9_]+ *$/i) && stream.peek()==\"(\") &&\n                     !(functions && functions.propertyIsEnumerable(word.toLowerCase()))) {\n                state.beforeParams = true;\n                state.lastTokenWasBuiltin = false;\n                return \"keyword\";\n            }\n            if (state.inString) {\n                state.lastTokenWasBuiltin = false;\n                return \"string\";\n            }\n            if (stream.pos > word.length && stream.string.charAt(stream.pos-word.length-1)==\".\" && state.lastTokenWasBuiltin)\n                return \"builtin\";\n            // default: just a \"word\"\n            state.lastTokenWasBuiltin = false;\n            return null;\n        }\n    }\n\n    function tokenString(quote) {\n        return function(stream, state) {\n            var escaped = false, next, end = false;\n            while ((next = stream.next()) != null) {\n                if ((next == quote) && !escaped) {\n                    end = true;\n                    break;\n                }\n                if (quote=='\"' && stream.peek() == '$' && !escaped) {\n                    state.inString = true;\n                    end = true;\n                    break;\n                }\n                escaped = !escaped && next == \"\\\\\";\n            }\n            if (end) state.tokenize = tokenBase;\n            return \"string\";\n        };\n    }\n\n    function tokenComment(stream, state) {\n        var maybeEnd = false, ch;\n        while (ch = stream.next()) {\n            if (ch == \"#\" && maybeEnd) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            maybeEnd = (ch == \"*\");\n        }\n        return \"comment\";\n    }\n\n    function tokenUnparsed(stream, state) {\n        var maybeEnd = 0, ch;\n        while (ch = stream.next()) {\n            if (ch == \"#\" && maybeEnd == 2) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            if (ch == \"]\")\n                maybeEnd++;\n            else if (ch != \" \")\n                maybeEnd = 0;\n        }\n        return \"meta\";\n    }\n    // Interface\n\n    return {\n        startState: function() {\n            return {\n                tokenize: tokenBase,\n                beforeParams: false,\n                inParams: false,\n                inString: false,\n                lastTokenWasBuiltin: false\n            };\n        },\n\n        token: function(stream, state) {\n            if (stream.eatSpace()) return null;\n            return state.tokenize(stream, state);\n        },\n        blockCommentStart: \"#*\",\n        blockCommentEnd: \"*#\",\n        lineComment: \"##\",\n        fold: \"velocity\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/velocity\", \"velocity\");\n\n});\n"]}